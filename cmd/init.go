package cmd

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"

	"github.com/spf13/cobra"
)

var (
	projectName string
	moduleName  string
	arch        string
	framework   string
	fullLayout  bool
)

var initCmd = &cobra.Command{
	Use:   "init",
	Short: "Initialize a new project",
	Run: func(cmd *cobra.Command, args []string) {
		if projectName == "" || moduleName == "" || arch == "" {
			fmt.Println("--name, --mod, and --type are required")
			return
		}
		if arch == "microservice" {
			createMicroserviceFolder()
		} else {
			fmt.Println("Only microservice architecture is supported for now")
		}
	},
}

func init() {
	rootCmd.AddCommand(initCmd)
	initCmd.Flags().StringVarP(&projectName, "name", "n", "", "Project name")
	initCmd.Flags().StringVarP(&moduleName, "mod", "m", "", "Go module name")
	initCmd.Flags().StringVarP(&arch, "type", "t", "", "Architecture type: microservice")
	initCmd.Flags().StringVarP(&framework, "framework", "w", "", "Web framework: gin, echo")
	initCmd.Flags().BoolVarP(&fullLayout, "full", "f", false, "Include full standard layout")
}

func createMicroserviceFolder() {
	baseDirs := []string{
		"cmd",
		"config",
		"internal/handler",
		"internal/service",
		"internal/repository",
	}
	if fullLayout {
		baseDirs = append(baseDirs, "api", "pkg", "scripts", "test", "build")
	}
	for _, dir := range baseDirs {
		path := filepath.Join(projectName, dir)
		if err := os.MkdirAll(path, 0755); err != nil {
			fmt.Printf("Failed to create directory %s: %v\n", path, err)
			return
		}
	}
	files := map[string]string{
		"main.go":    generateMainFile(framework),
		"go.mod":     fmt.Sprintf("module %s\n\ngo 1.21", moduleName),
		"README.md":  fmt.Sprintf("# %s\n\nGenerated by go-boil CLI.", projectName),
		".gitignore": "bin/\n*.log\n.env\n",
	}
	if fullLayout {
		files["Makefile"] = "build:\n\tgo build -o bin/" + projectName + " ./..."
		files["Dockerfile"] = `FROM golang:1.21-alpine
WORKDIR /app
COPY . .
RUN go build -o main .
CMD [\"./main\"]`
	}
	for name, content := range files {
		path := filepath.Join(projectName, name)
		if err := os.WriteFile(path, []byte(content), 0644); err != nil {
			fmt.Printf("Failed to write file %s: %v\n", path, err)
			return
		}
	}
	if framework != "" {
		fmt.Printf("Installing framework %s...\n", framework)
		cmd := exec.Command("go", "get", getFrameworkModule(framework))
		cmd.Dir = projectName
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		if err := cmd.Run(); err != nil {
			fmt.Printf("Error installing %s: %v\n", framework, err)
		}
	}
	fmt.Printf("Project '%s' scaffolded successfully.\n", projectName)
}

func generateMainFile(framework string) string {
	switch framework {
	case "gin":
		return `package main

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

func main() {
	r := gin.Default()

	r.GET("/ping", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"message": "pong"})
	})

	r.Run()
}`
	case "echo":
		return `package main

import (
	"github.com/labstack/echo/v4"
	"net/http"
)

func main() {
	e := echo.New()

	e.GET("/ping", func(c echo.Context) error {
		return c.JSON(http.StatusOK, map[string]string{"message": "pong"})
	})

	e.Start(":8080")
}`
	default:
		return `package main

import "fmt"

func main() {
	fmt.Println("Hello, world!")
}`
	}
}

func getFrameworkModule(framework string) string {
	switch framework {
	case "gin":
		return "github.com/gin-gonic/gin"
	case "echo":
		return "github.com/labstack/echo/v4"
	default:
		return ""
	}
}
